load "ozmansiksek2.m";
load "QuarticsieveXb5ns7.m";
load "DNS.m";


X:=Curve(Xb5ns7);
XlHtoX:=XlHtoXb5ns7;
w5:=iso<X->X | [-u,-v,w],[-u,-v,w]>;


Cprime,projCprime:=CurveQuotient(AutomorphismGroup(X,[w5]));
C,h:=SimplifiedModel(Cprime);
XtoC:=Expand(projCprime*h);
ptsC:=Setseq(Points(C : Bound:=1000)); //8 points
//We use an algorithm of Stoll to show that J(C)(Q) is generated by deg1C[3]-deg1C[1] and deg1C[5]-deg1C[1], corresponding to D1 and D2 below. bp corresponds to ptsC[1].
J:=Jacobian(C);
assert #TorsionSubgroup(J) eq 1; 
ptsJ:=[pt-ptsC[1] : pt in ptsC]; 
Q1:=ptsJ[3];
Q2:=ptsJ[5];
bas,M:=ReducedBasis([Q1,Q2]);
assert #bas eq 2;//This shows J(C)(\Q) has rank 2;
//We will show that Q1,Q2 are a basis using Stoll's algorithm
N:=Orthogonalize(M);
absbd:=Ceiling(Exp((N[1,1]^2+N[1,2]^2+N[2,1]^2+N[2,2]^2)/4+HeightConstant(J)));
//J(C)(\Q) is generated by P1,P2 and all points of height up to absbd.
PtsUpToAbsBound:=Points(J : Bound:=absbd);
assert ReducedBasis([pt : pt in PtsUpToAbsBound]) eq [-Q2,-Q1-Q2]; //This shows Q1,Q2 are a basis.

d1:=Place(ptsC[3])-Place(ptsC[1]);
d2:=Place(ptsC[5])-Place(ptsC[1]);

print "Searching for degree 4 points on X.";
deg2,pls1,pls2,plsbig:=searchDiv2(X,5,[w5]);
pls2:=pls2 cat [Pullback(XtoC,Place(P)) : P in ptsC];
pls4:=[DD : DD in plsbig | Degree(DD) eq 4];
pls3:=[DD : DD in plsbig | Degree(DD) eq 3];
deg4:=[1*pl1+1*pl2+1*pl3+1*pl4 : pl1 in pls1, pl2 in pls1, pl3 in pls1, pl4 in pls1] cat [1*pl1 + 1*pl2 + 1*pl3 : pl1 in pls1, pl2 in pls1, pl3 in pls2] cat [pls2[i1] + pls2[i2] : i1 in [1..#pls2], i2 in [1..#pls2] | i2 le i1] cat [1*pl1 + 1*pl2 : pl1 in pls1, pl2 in pls3] cat [1*pl : pl in pls4];
deg4npb:=Setseq({DD : DD in deg4 | not Pullback(w5,DD) eq DD}); 

genusC:=2;
auts:=[Matrix([[-1,0,0],[0,-1,0],[0,0,1]])];
n:=Dimension(AmbientSpace(X));

bpideal:=ideal<CoordinateRing(AmbientSpace(X)) | [
    v^2 - 4/5*w^2,
    u - 5/2*v]>;
bp:=Divisor(X,bpideal); //This is the basepoint for our map X^{(2)} --> J.
I1:=ideal<CoordinateRing(AmbientSpace(X)) | [v^2 + 1/11*w^2,u - 2*v]>;
I2:=ideal<CoordinateRing(AmbientSpace(X)) | [v^2 + 1/4*w^2,u]>;
I0:=ideal<CoordinateRing(AmbientSpace(X)) | [
    u^3 - 44/7*u*w^2 + 29/7*v*w^2 - 12/7*w^3,
    u^2*v - 27/14*u*w^2 + 17/14*v*w^2 - 1/2*w^3,
    u*v^2 - 4/7*u*w^2 + 2/7*v*w^2 - 1/7*w^3,
    v^3 - 1/14*u*w^2 - 3/14*v*w^2 - 1/14*w^3,
    u^2*w - 37/14*u*w^2 + 29/14*v*w^2 - 13/14*w^3,
    u*v*w - 11/14*u*w^2 + 9/14*v*w^2 - 5/14*w^3,
    v^2*w - 1/14*u*w^2 - 3/14*v*w^2 - 3/14*w^3]>;
c0:=Divisor(X,I0); //The first degree 3 Galois orbit of cusps.
cinf:=Pullback(w5,c0); //The second degree 3 Galois orbit of cusps.
assert Place(invTQ(F(L)!c0F)) eq c0;
Dtor:=c0-cinf;
D1:=Divisor(X,I1)-bp;
D2:=Divisor(X,I2)-bp;
assert D1 eq Pullback(XtoC,d1) and D2 eq Pullback(XtoC,d2);
bp:=2*bp; //Need a degree 4 basepoint from now on.

//The sieve initially didn't terminate, but did point us in the direction of new pairs of degree 4 places.
for D in [3*Dtor+D1-D2,3*Dtor-D1-3*D2,3*Dtor-D1-4*D2] do
    RRsp,phimap:=RiemannRochSpace(D+bp);
    deco:=Decomposition(Divisor(phimap(RRsp.1)));
    extrapls:=[d[1] : d in deco | Degree(d[1]) eq 4][1];
    extrapls2:=Pullback(w5,extrapls);
    Append(~deg4npb,1*extrapls);
    Append(~deg4npb,extrapls2);
end for;
print "The number of non-pullbacks is"; #deg4npb;

divs:=[D1,D2,Dtor];

//We use p=19 to check that D2 is not a double in J_X(Q)
for p in [19] do
    Xp:=ChangeRing(X,GF(p));
    CC,phi,psi:=ClassGroup(Xp);
    Z:=FreeAbelianGroup(1);
    degr:=hom<CC->Z | [ Degree(phi(a))*Z.1 : a in OrderedGenerators(CC)]>;
    JFp:=Kernel(degr); // This is isomorphic to J_X(\F_p).
    divsp:=[reduce(X,Xp,divi) : divi in divs];
    h:=hom<A -> JFp | [JFp!psi(divp) : divp in divsp]>; //The map A--> J_X(\F_p).
    m2:=hom<JFp -> JFp | [2*g : g in OrderedGenerators(JFp)]>;
    assert not h(A.2) in Image(m2);
end for;

A:=AbelianGroup([0,0,7]);
B0,iA0:=sub<A | A.1,2*A.2>; //Since D2 is not a double, we end up in B0 x <A.3> after multiplying by I=2.
W0s:={{A.3},{2*A.3},{3*A.3}}; //The option 0*A.3 we have excluded theoretically, and the possibilities k*A.3 and -k*A.3 are w5-symmetric, so it suffices to consider A.3, 2*A.3 and 3*A.3.
primes:=[11,13,17,23,53,29,71,43,37,31];
I:=2;

assert &and[MWSieve(X,w5,deg4npb,primes,A,divs,I,bp,B0,iA0,W0) : W0 in W0s];

/*
//We check here that the normalisation of the naive reduction of D is indeed *the* reduction of the abstract curve X(b5,ns7).
//Note that canonImage is a smooth model for X(b5,ns7), so if that model has non-singular reduction at p then we have found *the* reduction.
for p in [q : q in PrimesUpTo(102) | q gt 7] do
    p;
    Cp:=ChangeRing(canonImage,GF(p));
    Dimension(Cp);
    if Dimension(Cp) eq 1 then
        IsSingular(Cp);
        Dp:=ChangeRing(D,GF(p));
        FCp:=AlgorithmicFunctionField(FunctionField(Cp));
        FDp:=AlgorithmicFunctionField(FunctionField(Dp));
        IsIsomorphic(FCp,FDp) eq true; //If this is true, then Dp and Cp are birational and J(Dp) = J(Cp)
     end if;
end for;
//This leaves the prime 13 to be checked, as for 13 we have Dimension(Cp) = 3.
C:=canonImage;
P5<[x]>:=AmbientSpace(C);
h:=map<C -> P5 | [x[1],x[2]-x[1],x[3],x[4],x[5],x[5]]>; //a random isomorphism onto its image
C1:=Image(h); 
C113:=ChangeRing(C1,GF(13));
assert Dimension(C113) eq 1;
assert not IsSingular(C113);
FC13:=AlgorithmicFunctionField(FunctionField(C113));
FD13:=AlgorithmicFunctionField(FunctionField(ChangeRing(D,GF(13))));
assert IsIsomorphic(FC13,FD13);
*/

