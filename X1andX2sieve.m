//The sieve for quadratic points on X in {X(b5,e7)/w5,X(b5,e7)/phi7*w5}.
//Let Y be one of X_0(15) and X(s3,b5). 
//The purpose of the sieve is to show that there are no quadratic points on X 
//giving rise to quartic points on both Y and X(e7), 
//except possibly for the 6 pairs of quadratic points mapping to rational points on C.

//We first compute explicitly the diagram with maps between the various curves.
         
load "Xb5ns7.m";

//We already have models for X(b5,ns7), X1 and X2 with maps to C=X(b5,ns7)/w_5,
//as well as the maps X(b5,ns7) --> X05 and X(b5,ns7) --> X(ns7).

//--------------X(b3,ns7)------------------

//We copy-paste equations for the curve from the Sage file.
P4<X0,X1,X2,X3,X4>:=ProjectiveSpace(Rationals(),4);
Xb3ns7:=Curve(P4,[10528*X0^2 - 21*X1*X2 - 112*X2^2 - 1136*X0*X3 - 17*X3^2 - 1016*X0*X4 + 273*X3*X4 - 176*X4^2, 40*X0*X1 + 8*X0*X2 + X1*X3 + 3*X2*X3 - 7*X1*X4, 47*X1^2 + 58*X1*X2 - 4*X2^2 - 336*X0*X3 - 9*X3^2 - 560*X0*X4 - 2*X3*X4 - 60*X4^2]);
w3:=iso<Xb3ns7->Xb3ns7 | [X0,-X1,-X2,X3,X4],[X0,-X1,-X2,X3,X4]>;
CC2,pi2:=CurveQuotient(AutomorphismGroup(Xb3ns7,[w3]));
C2,m:=SimplifiedModel(CC2);
Xb3ns7toC2:=pi2*m;
assert Genus(Xb3ns7) eq 5;
assert Genus(C2) eq 2;
ptsC2:=Points(C2 : Bound:=500);

//We remove unnecessary factors from the equations of the quotient map.
defss:=DefiningEquations(Xb3ns7toC2);
for p in PrimesUpTo(500) do
    m1:=Minimum([Valuation(c,p) : c in Coefficients(defss[1]) cat Coefficients(defss[3])]);
    m2:=Minimum([m1] cat [Floor(Rationals()!Valuation(c,p)/3) : c in Coefficients(defss[2])]);
    defss:=[p^(-m2)*defss[1],p^(-3*m2)*defss[2],p^(-m2)*defss[3]];
end for;
Xb3ns7toC2:=map<Xb3ns7->C2 | defss>;

//We use an algorithm of Stoll to compute the MW group of C2.
J:=Jacobian(C2);
twotor,emb:=TorsionSubgroup(J);
assert #twotor eq 2;
assert emb(twotor.1) eq ptsC2[5]-ptsC2[12];
Q1:=ptsC2[4]-ptsC2[1];
Q2:=ptsC2[5]-ptsC2[1];
bas,M:=ReducedBasis([Q1,Q2]);
assert #bas eq 2;//This shows J(CX)(\Q) has rank 2;
//We will show that Q1,Q2 are a basis using Stoll's algorithm
N:=Orthogonalize(M);
absbd:=Ceiling(Exp((N[1,1]^2+N[1,2]^2+N[2,1]^2+N[2,2]^2)/4+HeightConstant(J)));
//J(CX)(\Q) is generated by P1,P2 and all points of height up to absbd.
PtsUpToAbsBound:=Points(J : Bound:=absbd);
assert ReducedBasis([pt : pt in PtsUpToAbsBound]) eq [Q1,-Q2+emb(twotor.1)];

//The save the generators of the MW-group as degree 0 divisors.
d21:=Divisor(ptsC2[4])-Divisor(ptsC2[1]);
d22:=Divisor(ptsC2[5])-Divisor(ptsC2[1]);
d2tor:=Divisor(ptsC2[5])-Divisor(ptsC2[12]);

//Next, we copy-paste q-expansions of the modular forms computed in the Sage file,
//and use these to determine the map X(b3,ns7) --> X(ns7)

//Recall that we have imported the cusp forms defining our canonical model for X(b3,ns7)
//Here fi corresponds to the variable Xi.
Bexp:=[LL!f : f in cuspformsXb3ns7];
Xns7:=Curve(ProjectiveSpace(Rationals(),1));
Xb3ns7toXns7:=MapToP1FromqExp(Xb3ns7,Bexp,Xns7,n7,4);


//------------X(e7)------------------------------------

R<xe7>:=PolynomialRing(Rationals());
Xe7:=HyperellipticCurve(7*(16*xe7^4 + 68*xe7^3 + 111*xe7^2 + 62*xe7 + 11)); 
//The curve as determined by Freitas, Le Hung and Siksek.
R<xe7,ye7,ze7>:=CoordinateRing(AmbientSpace(Xe7));
ptse7:=Setseq(Points(Xe7 : Bound:=200)); //Two rational points
Ee7,me7:=EllipticCurve(Xe7,ptse7[2]); //The corresponding elliptic curve.
D7:=Divisor(ptse7[1])-Divisor(ptse7[2]); //The generator of the M-W group (checked below).
bpe7:=Divisor(ptse7[2]); //The base point for the Abel--Jacobi map.
MWEe7,embe7,tf1,tf2:=MordellWeilGroup(Ee7);
assert &and[tf1,tf2, #MordellWeilGroup(Ee7) eq 2];
assert Pullback(me7,Place(embe7(MWEe7.1))-Place(Zero(Ee7))) eq D7;
//The map to Xns7+ is (x,y) :--> x, as per Freitas--Le Hung--Siksek
CR<xns7,yns7>:=CoordinateRing(AmbientSpace(Xns7));
Xe7toXns7:=map<Xe7 -> Xns7 | [xe7,ze7]>;


//-------------- X(s3,b5)--------------------------

//We use the isomorphism X(s3,b5) \simeq X_0(45)/w_9.
Xs3b5toX05:=MapFromQuotient(45,[9],5);
//We make sure the codomain is X05 as defined in "Xb5ns7.m"
CR05:=CoordinateRing(AmbientSpace(Codomain(Xs3b5toX05)));
X05toX05:=map<Codomain(Xs3b5toX05)->X05 | [CR05.1,CR05.2]>;
Xs3b5toX05:=Xs3b5toX05*X05toX05; 
Xs3b5:=Domain(Xs3b5toX05);
pts35:=PointSearch(Xs3b5,200);
EE,mm:=EllipticCurve(Xs3b5,pts35[1]);
tf,invmm:=IsInvertible(mm);
Xs3b5,m:=SimplifiedModel(EE); //We consider Xs3b5 as elliptic curve.
Xs3b5toX05:=Inverse(m)*invmm*Xs3b5toX05; //The map E -> X05.

//We remove "excess" prime factors from themap to shorten computations
//and ensure the map reduces as it should mod primes.
defss3b55:=DefiningEquations(Xs3b5toX05);
for p in PrimesUpTo(100) do
    m:=Minimum([Valuation(c,p) : c in &cat[Coefficients(eqn) : eqn in defss3b55]]);
    defss3b55:=[p^(-m)*a : a in defss3b55];
end for;
Xs3b5toX05:=map<Xs3b5->X05 | defss3b55>;


//---------------X_0(15)----------------------------------

X015:=SmallModularCurve(15);
X015toX05:=ProjectionMap(X015,15,X05,5);

//We note that all maps to X05 (from X_0(15), X(s3,b5) and X(b5,ns7)) were computed
//using the *same* Hauptmodul on X05, so they are compatible.
//Similarly, both X(b5,ns7) --> X(ns7) and X(e7)-->X(ns7) were computed
//using Chen's j-map on X(ns7) (and corresponding Hauptmodul).


//----------------Computing Mordell--Weil groups------------------

MWs3b5,phi35:=MordellWeilGroup(Xs3b5);
assert IsIsomorphic(MWs3b5,AbelianGroup([2,4]));
assert Order(MWs3b5.1) eq 2 and Order(MWs3b5.2) eq 4;
D3:=Divisor(phi35(MWs3b5.1))-Divisor(Zero(Xs3b5));
D4:=Divisor(phi35(MWs3b5.2))-Divisor(Zero(Xs3b5));
MW15,phi15:=MordellWeilGroup(X015);
assert IsIsomorphic(MW15,AbelianGroup([2,4]));
assert Order(MW15.1) eq 2 and Order(MW15.2) eq 4;
D5:=Divisor(phi15(MW15.1))-Divisor(Zero(X015));
D6:=Divisor(phi15(MW15.2))-Divisor(Zero(X015));
d1:=Place(ptsC[3])-Place(ptsC[1]);
d2:=Place(ptsC[5])-Place(ptsC[1]); //Recall that d1,d2 generate the MW group of C.
bpC2:=4*Place(ptsC2[1]);

bp:=Place(ptsC[1])+Place(ptsC[2]); //Basepoint for Abel--Jacobi map
A:=AbelianGroup([0,0,2,2,4,0,0,2]); //Generated by d1,d2,D7,D3,D4,d21,d22,d2tor (or replace D3,D4 by D5,D6)


//-------------MORDELL-WEIL SIEVE FOR QUADRATIC POINTS--------------

//This sieve was designed particularly for our situation. It can be applied to X1 or to X2,
//and using either X(s3,b5) or X_0(15). 

//This function verifies that the residue class of XtoC*(ptsC[i]) contains only pullbacks.
//a0sp is a list of a0-coefficients of reductions of vanishing differentials.
IsOnlyWithFamily:=function(i,p,a0sp)
if p le 11 then //Small primes condition in Chabauty.
return false;
end if;
a0list:=a0sp[i];
if not &and[a eq 0 : a in a0list] then
return true;
else return false;
end if;
end function;


/*This function sieves at the prime p. Input are a prime p, and a set deg2pb of degree 2
divisors on X (the known points). In our case all of these are pullbacks.
Also input: the function t defining X1 or X2 as a double cover of C,
a map EtoX05 where E is X(s3,b5) or X_0(15), a list divs of degree 0 divisors
generating the Mordell--Weil groups, a list unifsC of uniformiser at the known
rational points of C, and a list exps of expansions of (global) vanishing differentials
at the (irreducible) degree 2 divisors in deg2pb. 
Finally, a map iA: B --> A and a set W of B-coset representatives in A.

Output: a new (smaller) subgroup B of A together with the inclusion map
iA: B --> A and the set W \subset A of possible B-cosets the sieve allows. */

ChabautyInfo:=function(deg2pb,p,B,iA,W,t,EtoX05,divs,unifsC,exps)
degEtoX05:=Degree(EtoX05);
Fp:=GF(p);
Fp2:=GF(p^2);
Cp:=ChangeRing(C,Fp);
assert not IsSingular(Cp);
assert &and[Valuation(Divisor(reduceFunction(unifsC[i],C,Cp)),Decomposition(1*reduce(C,Cp,Place(ptsC[i])))[1][1]) eq 1 : i in [1..#ptsC]];
//The above shows that unifsC are well-behaved uniformizers at the points in ptsC, 
//and hence unifsX are well-behaved at the pts in deg2pb as long there is no ramification mod p (which we check below).
a0sp:=<[a0(exp,p,Fp2) : exp in ee] : ee in exps>;

//We reduce all relevant objects mod p. First curves and maps.
tp:=reduceFunctionSc(t,C,Cp,ptsC); //tp checks whether a place on Cp splits on X or not.
assert &and[not EvalNotInf(tp,Decomposition(reduce(C,Cp,Place(P)))[1][1]) eq 0  : P in ptsC]; //Indeed no ramification.
Xb5ns7p:=ChangeRing(Xb5ns7,Fp);
Rp<[xp]>:=CoordinateRing(AmbientSpace(Xb5ns7p));
Xns7p:=ChangeRing(Xns7,Fp);
Rns7p<xns7p,zns7p>:=CoordinateRing(AmbientSpace(Xns7p));
Xb5ns7toCp:=map<Xb5ns7p->Cp | [Evaluate(eqn,xp): eqn in DefiningEquations(Xb5ns7toC)]>;
Xe7p:=ChangeRing(Xe7,Fp);
Re7p<xe7p,ye7p,ze7p>:=CoordinateRing(AmbientSpace(Xe7p));
Xe7toXns7p:=map<Xe7p -> Xns7p | [Evaluate(eqn, [xe7p,ye7p,ze7p]) : eqn in DefiningEquations(Xe7toXns7)]>;
Xb5ns7toXns7p:=map<Xb5ns7p -> Xns7p | [Evaluate(eqn,xp) : eqn in DefiningEquations(Xb5ns7toXns7)]>; 
X05p:=ChangeRing(X05,Fp);
Xb5ns7toX05p:=map<Xb5ns7p -> X05p | [Evaluate(eqn,xp) : eqn in DefiningEquations(Xb5ns7toX05)]>;
eqns05p:=DefiningEquations(Xb5ns7toX05p);
RF:=FieldOfFractions(Parent(eqns05p[1]));
prX05fnp:=FunctionField(Xb5ns7p)!((RF!eqns05p[1])/(RF!eqns05p[2]));
eqnsns7p:=DefiningEquations(Xb5ns7toXns7p);
prXns7fnp:=FunctionField(Xb5ns7p)!((RF!eqnsns7p[1])/(RF!eqnsns7p[2]));
Xb3ns7p:=ChangeRing(Xb3ns7,Fp);
Rp<[xp]>:=CoordinateRing(AmbientSpace(Xb3ns7p));
C2p:=ChangeRing(C2,Fp);
Xb3ns7toC2p:=map<Xb3ns7p->C2p | [Evaluate(eqn,xp): eqn in DefiningEquations(Xb3ns7toC2)]>;
Xb3ns7toXns7p:=map<Xb3ns7p -> Xns7p | [Evaluate(eqn,xp) : eqn in DefiningEquations(Xb3ns7toXns7)]>; 
g1,g2,g3:=Explode(DefiningEquations(Xb3ns7toC2p));
FR:=FieldOfFractions(Parent(g1));
FF:=FunctionField(Xb3ns7p);
f1:=FF!((FR!g1)/(FR!g3));
f2:=FF!((FR!g2)/(FR!g3^3));

E:=Domain(EtoX05);
Ep:=ChangeRing(E,Fp);
REp<xEp,yEp,zEp>:=CoordinateRing(AmbientSpace(Ep));
EtoX05p:=map<Ep -> X05p | [Evaluate(eqn,[xEp,yEp,zEp]) : eqn in DefiningEquations(EtoX05)]>;

//Then basepoints for the Abel--Jacobi maps...
bpE:=Place(Zero(Ep));
bpe7p:=reduce(Xe7,Xe7p,bpe7);
bpC2p:=4*Place(C2p!Eltseq(ptsC2[1]));
bpp:=reduce(C,Cp,bp);
//... and the generators of the Mordell--Weil groups.
divsp:=<reduce(C,Cp,divs[1]),reduce(C,Cp,divs[2]),reduce(Xe7,Xe7p,divs[3]),reduce(E,Ep,divs[4]),reduce(E,Ep,divs[5]),Place(C2p!Eltseq(ptsC2[4]))-Place(C2p!Eltseq(ptsC2[1])),Place(C2p!Eltseq(ptsC2[5]))-Place(C2p!Eltseq(ptsC2[1])),Place(C2p!Eltseq(ptsC2[5]))-Place(C2p!Eltseq(ptsC2[12]))>;
//We reduce the 6 rational pts on C and run IsOnlyWithFamily
redsC:=[2*reduce(C,Cp,Place(pt)): pt in ptsC]; //Doubles of rational points, reduced
tfs:=[IsOnlyWithFamily(i,p,a0sp) : i in [1..#redsC]]; //We check which quadratic places have only pullbacks in their residue class
//tfs:=[true,true,true,true,true,true]; //Use this line to test the sieve without having to wait for an hour to compute exps.

//We now compute M--W groups over Fp
JEFp,phiCE,psiCE:=JacobianFp(Ep);
Je7Fp,phie7,psie7:=JacobianFp(Xe7p);
JFp,phii,psi:=JacobianFp(Cp);
JC2Fp,phi2,psi2:=JacobianFp(C2p);

//When sieving we neglect all factors of JFp whose order is not a power of a small prime, 
//by multiplying by such numbers. This greatly improves the speed of the sieve. 
fact:=Factorization(#JFp);
fact2:=Factorization(#JC2Fp);
n:=1;
for pp in fact cat fact2 do
    if pp[1] gt 11 and not pp[1] in [17,23,31,41,71] then n:=n*pp[1]^(pp[2]);
    end if;
end for;
mn:=hom<JFp -> JFp | [n*g : g in OrderedGenerators(JFp)]>; 

//We construct maps from A to the various M--W groups.
JxJxJ,phis:=DirectSum([JFp,Je7Fp,JEFp,JC2Fp]);
mnJxJxJ:=hom<JxJxJ -> JxJxJ | [n*g : g in OrderedGenerators(JxJxJ)]>;
hC:=hom<A -> JFp | [JFp!psi(divsp[1]),JFp!psi(divsp[2])] cat [JFp!0,JFp!0,JFp!0,JFp!0,JFp!0,JFp!0]>; //The map A--> J_C(\F_p).

//We distinguish here the cases where we do and don't use X(b3,ns7)/w_3 and its MW group.
if gX eq 8 and degEtoX05 eq 4 then
h:=hom<A -> JxJxJ | [phis[1](JFp!psi(divsp[1])),phis[1](JFp!psi(divsp[2])),phis[2](Je7Fp!psie7(divsp[3])),phis[3](JEFp!psiCE(divsp[4])),phis[3](JEFp!psiCE(divsp[5])),phis[4](JC2Fp!psi2(divsp[6])),phis[4](JC2Fp!psi2(divsp[7])),phis[4](JC2Fp!psi2(divsp[8]))]>;
else h:=hom<A -> JxJxJ | [phis[1](JFp!psi(divsp[1])),phis[1](JFp!psi(divsp[2])),phis[2](Je7Fp!psie7(divsp[3])),phis[3](JEFp!psiCE(divsp[4])),phis[3](JEFp!psiCE(divsp[5])),phis[4](JC2Fp!0),phis[4](JC2Fp!0),phis[4](JC2Fp!0)]>;
end if;

//We now split our cosets in W into smaller cosets on which h takes a single value.
Bp,iAp:=sub<A | Kernel(h)>;
newB,newiA:=sub<A | iA(B) meet iAp(Bp)>;
AmodnewB,pi1:=quo< A | newiA(newB)>;
AmodB,pi2:=quo<AmodnewB | pi1(iA(B))>;
WW:=[(x+w)@@pi1 : x in Kernel(pi2), w in pi1(W)];
imWC:={hC(x) : x in WW};
newimW:={};

//For p ge 97 Magma struggles with the computation of Riemann--Roch spaces, so we compute effective degree 2 divisors by listing points. For this we make the following precomputation: we list all degree 2 effective divisors on Cp together with their images in the M--W group.
divwithimage:=[];
if p ge 97 then
    Ap:=AffinePatch(Cp,1);
    ptsAp:=Points(Ap,Fp2);
    pts2:=[Place(Cp(Fp2)!(Eltseq(pt) cat [1])) : pt in ptsAp] cat [Place(pt) : pt in PointsAtInfinity(Cp)];
    pls2:=[P : P in pts2 | Degree(P) eq 2];
    pls1:=[P : P in pts2 | Degree(P) eq 1];
    divs2:=pls2 cat [pls1[i]+pls1[j] : i in [1..#pls1], j in [1..#pls1] | i le j]; //All deg 2 divs occur twice, but removing doubles is expensive.
    divwithimage:=[<D,JFp!(psi(D-bpp))> : D in divs2];
end if;

//The below for-loop will decide which points in imW correspond to effective degree 2,4,4 divisors 
//on X, Xe7 and E respectively, which could come from a rational degree 4 divisor on X(s3,b5,e7), or X(b3,b5,e7). 
//For each element x in imWC \subset J_C(F_p), we find the elements of A mapping to
//(x,y,z) in JxJxJ for some allowed y,z. 

for x in imWC do
    if (not p ge 97 and not p eq 79) or (x eq hC(A!0)) then
    phx:=phii(x);
    V,PHI:=RiemannRochSpace(phx+bpp);
    fns:=[PHI(V.i) : i in [1..Dimension(V)]];
    CP:=ProjectiveSpace(Fp,#fns-1);
    divsx:=[Divisor(&+[a[i]*fns[i] : i in [1..#fns]])+bpp+phx : a in Points(CP,Fp)]; //The deg2 divs mapping to x.
    //if x is not zero then #divsx \leq 1, else #divsx = p+1
    else divsx:=Setseq({DD[1] : DD in divwithimage | DD[2] eq x});
    end if;
    
    for divx in divsx do
    dec:=Decomposition(divx);
    //The below if-statement checks whether divx could come from an eff degr 2 div on X that isn't a pullback.
    if (#dec eq 1 and dec[1][2] eq 1 and IsSquare(EvalNotInf(tp,dec[1][1]))) 
        or (#dec eq 2 and IsSquare(EvalNotInf(tp,dec[1][1])) and IsSquare(EvalNotInf(tp,dec[2][1]))) 
        or (#dec eq 1 and dec[1][2] eq 2 and not dec[1][2]*dec[1][1] in redsC) 
        or (#dec eq 1 and (dec[1][2]*dec[1][1] in redsC) and not tfs[Index(redsC,dec[1][2]*dec[1][1])]) then 
        
        //Now we check which deg4 eff divisors on Xe7 and E divx could come from.
        pbXb5ns7:=Pullback(Xb5ns7toCp,divx); //We pull back to Xb5ns7,
        pfwdd:=quickpfwd(prXns7fnp,pbXb5ns7,Xns7p); //push forward to Xns7
        De7s:=InvImages(Xe7toXns7p,pfwdd); //and find deg 2 divs on Xe7 pushfing fwd to pfwd.
        pfwd:=quickpfwd(prX05fnp,pbXb5ns7,X05p); //We do the same to E.
        DEs:=InvImages(EtoX05p,pfwd);
        DC2s:=[];
        if (not gX eq 8) or (not degEtoX05 eq 4) then
        DC2s:=[bpC2p]; //We artificially add this in the cases where we do not use Xb3ns7. 
        elif not #DEs eq 0 then //Saves time
        pbXb3ns7:=InvImages(Xb3ns7toXns7p,pfwdd);
        for DD in pbXb3ns7 do
            Append(~DC2s,quickpfwdhyp2(f1,f2,DD,C2p));
        end for;
        end if;
        
        //Finally we multiply all these options by n and add them.
        newimW:=newimW join {mnJxJxJ(H) : H in 
            ({phis[1](x)+phis[2](Je7Fp!psie7(DD-Degree(DD)*bpe7p))+phis[3](JEFp!psiCE(dd-Degree(dd)*bpE))+phis[4](JC2Fp!psi2(dd2-bpC2p))
                : DD in De7s, dd in DEs, dd2 in DC2s})};
    end if;
    end for; 
end for;

mnjposP:=newimW;
print "The number of elements in mnjposP is"; #mnjposP;

//Finally we save only the information up to multiplication by n. 
h:=h*mnJxJxJ;
Bp,iAp:=sub<A | Kernel(h)>;
newB,newiA:=sub<A | iA(B) meet iAp(Bp)>;
AmodnewB,pi1:=quo< A | newiA(newB)>;
AmodB,pi2:=quo<AmodnewB | pi1(iA(B))>;
W:=[(x+w)@@pi1 : x in Kernel(pi2), w in pi1(W)];
B:=newB; iA:=newiA;
W:=[x : x in W | h(x) in mnjposP];
return W,B,iA;
end function;


// L is a set of known points on X.
// primes is the set of primes of good reduction you want the sieve to consider.
// Also assume A is the abstract abelian group generated by divs in J(X)(\Q)
// such that A.i corresponds to divs[i] for each i.

MWSieve:=function(L,primes,t,EtoX05,divs,unifsC,exps,T)
//We distinguish between the case where we start with a specific coset T, and the case where we don't
if #T gt 0 then
B,iA:=sub<A|A.1,A.2,A.6,A.7>; //This subgroup will shrink as we consider more primes. We excluded the coset 0+B because it corresponds to points from the quotient.
W:={T[1]*A.3+T[2]*A.4+T[3]*A.5+T[4]*A.8};
else  B,iA:=sub<A|A>;
W:={0*A.1};
end if;
// Together, B+W \subset A consists of the possible images of unknown (rational)
// points in A. The map X(\Q) \to A is composition of X(\Q) \to J(X)(\Q) and
// multiplication by integer I such that I*J(X)(\Q) \subset A.

for p in primes do
p;
W,B,iA:=ChabautyInfo(L,p,B,iA,W,t,EtoX05,divs,unifsC,exps);
if W eq [] then print "The sieve has terminated successfully."; 
return true; end if;
print "The number of remaining cosets #W = ", #W;
end for;
return B,iA,W;
end function;




